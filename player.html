<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>BTF TV ‚Äì Reels Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <!-- Font Awesome 6 -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    body {
      font-family: 'Poppins', sans-serif;
      background: black;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      position: fixed;
      inset: 0;
      color: white;
    }
    #player {
      position: relative;
      width: 100%;
      height: 100%;
      background: black;
    }
    .video-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      background: black;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      background: black;
    }
    /* gesture overlay ‚Äì divided into left/right for double-tap */
    .gesture-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      z-index: 15;
    }
    .gesture-left, .gesture-right {
      flex: 1;
      height: 100%;
    }
    /* top bar */
    .top-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 16px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.6) 0%, transparent 100%);
      z-index: 20;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .top-bar * {
      pointer-events: auto;
    }
    .back-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(34,34,34,0.8);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,255,255,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      color: white;
      cursor: pointer;
    }
    .back-btn:active {
      background: #FFD700;
      color: black;
    }
    .show-title {
      font-family: 'Bebas Neue', cursive;
      font-size: 1.4rem;
      color: white;
      text-shadow: 0 2px 4px black;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }
    /* playlist button ‚Äì top right */
    .playlist-btn {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: rgba(34,34,34,0.8);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(255,215,0,0.3);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3rem;
      color: #FFD700;
      cursor: pointer;
      margin-left: auto;
    }
    .playlist-btn:active {
      background: #FFD700;
      color: black;
    }
    /* bottom bar */
    .bottom-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 20px 16px 30px;
      background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 100%);
      z-index: 20;
      pointer-events: none;
      transition: opacity 0.2s;
    }
    .bottom-bar * {
      pointer-events: auto;
    }
    .episode-info {
      margin-bottom: 12px;
    }
    .episode-title {
      font-family: 'Bebas Neue', cursive;
      font-size: 1.8rem;
      color: #FFD700;
      line-height: 1.2;
    }
    .episode-meta {
      font-size: 0.75rem;
      color: #ccc;
      display: flex;
      gap: 8px;
    }
    /* progress bar */
    .progress-container {
      width: 100%;
      height: 30px;
      display: flex;
      align-items: center;
      cursor: pointer;
      margin-bottom: 6px;
    }
    .progress-track {
      flex: 1;
      height: 4px;
      background: rgba(255,255,255,0.2);
      border-radius: 4px;
      position: relative;
    }
    .progress-fill {
      height: 100%;
      background: #FFD700;
      border-radius: 4px;
      width: 0%;
      pointer-events: none;
    }
    .progress-handle {
      width: 16px;
      height: 16px;
      background: #FFD700;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      left: 0%;
      opacity: 0;
      transition: opacity 0.1s;
    }
    .progress-container:active .progress-handle {
      opacity: 1;
    }
    .time-indicator {
      display: flex;
      justify-content: space-between;
      font-size: 0.7rem;
      color: #ddd;
      margin-top: 4px;
    }
    /* playlist drawer */
    .playlist-drawer {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 220px;
      background: rgba(10,10,10,0.98);
      backdrop-filter: blur(12px);
      border-left: 1px solid #333;
      z-index: 30;
      transform: translateX(100%);
      transition: transform 0.3s ease;
      padding: 20px 0;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
    }
    .playlist-drawer.open {
      transform: translateX(0);
    }
    .drawer-item {
      padding: 14px 20px;
      border-bottom: 1px solid #222;
      display: flex;
      align-items: center;
      gap: 12px;
      cursor: pointer;
      color: white;
      font-weight: 500;
    }
    .drawer-item.active {
      background: #FFD70020;
      border-left: 4px solid #FFD700;
    }
    .drawer-item.locked {
      color: #777;
    }
    .drawer-item.locked::after {
      content: '\f023';
      font-family: 'Font Awesome 6 Free';
      font-weight: 900;
      margin-left: auto;
      font-size: 0.9rem;
      color: #FFD700;
    }
    .drawer-item i {
      width: 24px;
      color: #FFD700;
    }
    /* next episode overlay */
    .next-overlay {
      position: absolute;
      bottom: 120px;
      left: 16px;
      right: 16px;
      background: rgba(20,20,20,0.95);
      backdrop-filter: blur(12px);
      border-radius: 40px;
      padding: 16px 24px;
      border: 1px solid rgba(255,215,0,0.3);
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 35;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
    }
    .next-overlay.show {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    .next-info {
      display: flex;
      flex-direction: column;
    }
    .next-label {
      font-size: 0.7rem;
      color: #FFD700;
      text-transform: uppercase;
    }
    .next-title {
      font-weight: 600;
      font-size: 1rem;
    }
    .next-actions {
      display: flex;
      gap: 16px;
    }
    .next-btn {
      background: none;
      border: none;
      color: white;
      font-size: 1.3rem;
      cursor: pointer;
    }
    .next-btn:active {
      color: #FFD700;
    }
    /* center icon (play/pause/skip) */
    .center-icon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70px;
      height: 70px;
      background: rgba(255,215,0,0.9);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2rem;
      color: black;
      z-index: 40;
      opacity: 0;
      transition: opacity 0.2s;
      pointer-events: none;
    }
    .center-icon.visible {
      opacity: 1;
    }
    /* loading spinner */
    #spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255,255,255,0.1);
      border-top-color: #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 50;
      display: none;
    }
    @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
    #spinner.show { display: block; }
    /* toast */
    #toast {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: #1a1a1a;
      color: white;
      border: 1px solid #333;
      padding: 10px 20px;
      border-radius: 40px;
      font-size: 0.85rem;
      font-weight: 600;
      z-index: 999;
      opacity: 0;
      transition: all 0.3s;
      pointer-events: none;
      white-space: nowrap;
    }
    #toast.on { opacity: 1; transform: translateX(-50%) translateY(0); }
    /* hidden */
    .hidden { display: none; }
  </style>
</head>
<body>
  <div id="player">
    <div class="video-wrapper">
      <video id="video" playsinline preload="auto" disablepictureinpicture></video>

      <!-- Gesture overlay -->
      <div class="gesture-overlay">
        <div class="gesture-left" id="gesture-left"></div>
        <div class="gesture-right" id="gesture-right"></div>
      </div>

      <!-- Top bar with playlist button -->
      <div class="top-bar">
        <button class="back-btn" id="back-btn"><i class="fas fa-arrow-left"></i></button>
        <div class="show-title" id="show-title">...</div>
        <div class="playlist-btn" id="playlist-toggle"><i class="fas fa-list-ul"></i></div>
      </div>

      <!-- Bottom bar -->
      <div class="bottom-bar">
        <div class="episode-info">
          <div class="episode-title" id="ep-title"></div>
          <div class="episode-meta" id="ep-meta"></div>
        </div>
        <!-- Progress bar -->
        <div class="progress-container" id="progress-container">
          <div class="progress-track">
            <div class="progress-fill" id="progress-fill"></div>
            <div class="progress-handle" id="progress-handle"></div>
          </div>
        </div>
        <div class="time-indicator">
          <span id="current-time">0:00</span>
          <span id="duration">--:--</span>
        </div>
      </div>

      <!-- Playlist drawer -->
      <div class="playlist-drawer" id="playlist-drawer"></div>

      <!-- Next episode overlay -->
      <div class="next-overlay" id="nextOverlay">
        <div class="next-info">
          <span class="next-label">‡§Ö‡§ó‡§≤‡§æ ‡§è‡§™‡§ø‡§∏‡•ã‡§°</span>
          <span class="next-title" id="next-title"></span>
        </div>
        <div class="next-actions">
          <button class="next-btn" id="next-cancel"><i class="fas fa-times"></i></button>
          <button class="next-btn" id="next-go"><i class="fas fa-step-forward"></i></button>
        </div>
      </div>

      <!-- Center icon (play/pause/skip) -->
      <div class="center-icon" id="centerIcon"><i class="fas fa-play"></i></div>

      <!-- Spinner -->
      <div id="spinner"></div>
    </div>
  </div>
  <div id="toast"></div>

  <script>
    (function() {
      'use strict';

      // ---------- SECURITY ----------
      document.addEventListener('contextmenu', e => e.preventDefault(), true);
      document.addEventListener('keydown', e => {
        const k = e.key.toLowerCase();
        if ((e.ctrlKey || e.metaKey) && ['s','u','a','c','j','i','p'].includes(k)) e.preventDefault();
        if (e.key === 'F12' || e.key === 'PrintScreen') e.preventDefault();
      }, true);
      document.addEventListener('dragstart', e => e.preventDefault(), true);
      document.addEventListener('drop', e => e.preventDefault(), true);
      document.addEventListener('selectstart', e => e.preventDefault(), true);
      document.addEventListener('touchstart', e => { if (e.target.tagName === 'VIDEO') e.preventDefault(); }, { passive: false });
      document.addEventListener('enterpictureinpicture', e => e.preventDefault(), true);

      // ---------- URL SHORTENER & SESSION EXPIRE ----------
      // We'll use localStorage to store mappings from short code to {sid, ei, expiry}
      const SESSION_DURATION = 60 * 60 * 1000; // 1 hour
      const CODE_LENGTH = 20; // characters

      function generateShortCode() {
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < CODE_LENGTH; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      // Check if current URL has a 'code' parameter
      const urlParams = new URLSearchParams(location.search);
      let code = urlParams.get('code');
      let sid, ei;

      if (code) {
        // Retrieve mapping from localStorage
        const mapping = JSON.parse(localStorage.getItem('btftv_codes') || '{}');
        const data = mapping[code];
        if (data && data.expiry > Date.now()) {
          sid = data.sid;
          ei = data.ei;
        } else {
          // Expired or not found
          toastMsg('‡§∏‡•á‡§∂‡§® ‡§∏‡§Æ‡§æ‡§™‡•ç‡§§ ‡§π‡•ã ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§ ‡§ï‡•É‡§™‡§Ø‡§æ ‡§´‡§ø‡§∞ ‡§∏‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•á‡§Ç‡•§');
          setTimeout(() => { window.location.href = 'index.html'; }, 2000);
          return;
        }
      } else {
        // No code, expect sid and ei
        sid = urlParams.get('sid');
        ei = parseInt(urlParams.get('ei') || '0', 10);
        if (!sid) {
          toastMsg('‡§ï‡•ã‡§à ‡§∂‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ');
          setTimeout(() => { window.location.href = 'index.html'; }, 2000);
          return;
        }
        // Generate short code and store mapping
        const shortCode = generateShortCode();
        const mapping = JSON.parse(localStorage.getItem('btftv_codes') || '{}');
        mapping[shortCode] = {
          sid: sid,
          ei: ei,
          expiry: Date.now() + SESSION_DURATION
        };
        localStorage.setItem('btftv_codes', JSON.stringify(mapping));
        // Redirect to short URL
        window.location.replace(location.pathname + '?code=' + shortCode);
        return; // stop further execution
      }

      // ---------- GLOBALS ----------
      let D = null;
      let show = null;
      let currentEpIndex = ei || 0;
      let autoNextTimer = null;
      let hideControlsTimer = null;
      let isDraggingProgress = false;
      let touchStartY = 0;
      let touchStartX = 0;
      let touchStartTime = 0;
      let lastTapTime = 0;
      const SWIPE_THRESHOLD = 50;
      const DOUBLE_TAP_DELAY = 300; // ms

      const video = document.getElementById('video');
      const progressFill = document.getElementById('progress-fill');
      const progressHandle = document.getElementById('progress-handle');
      const progressContainer = document.getElementById('progress-container');
      const currentTimeSpan = document.getElementById('current-time');
      const durationSpan = document.getElementById('duration');
      const playlistDrawer = document.getElementById('playlist-drawer');
      const playlistToggle = document.getElementById('playlist-toggle');
      const nextOverlay = document.getElementById('nextOverlay');
      const nextTitle = document.getElementById('next-title');
      const spinner = document.getElementById('spinner');
      const centerIcon = document.getElementById('centerIcon');
      const toast = document.getElementById('toast');

      let historyData = JSON.parse(localStorage.getItem('btftv_h') || '{}');

      // Cache name for videos
      const CACHE_NAME = 'btftv-videos-v1';
      const CACHE_EXPIRY = 60 * 60 * 1000; // 1 hour

      // ---------- UTILS ----------
      function fmtTime(seconds) {
        if (!seconds || isNaN(seconds)) return '0:00';
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return m + ':' + (s < 10 ? '0' : '') + s;
      }

      function toastMsg(msg) {
        toast.textContent = msg;
        toast.classList.add('on');
        setTimeout(() => toast.classList.remove('on'), 2500);
      }

      // ---------- CACHE VIDEO ----------
      async function getCachedVideo(url) {
        const cache = await caches.open(CACHE_NAME);
        const response = await cache.match(url);
        if (!response) return null;
        // Check if expired (using custom header)
        const cachedTime = response.headers.get('x-cached-time');
        if (cachedTime && (Date.now() - parseInt(cachedTime, 10)) < CACHE_EXPIRY) {
          return response;
        }
        // Expired, delete from cache
        await cache.delete(url);
        return null;
      }

      async function cacheVideo(url, blob) {
        try {
          const cache = await caches.open(CACHE_NAME);
          // Create a new response with blob and custom header
          const headers = new Headers({
            'Content-Type': 'video/mp4',
            'x-cached-time': Date.now().toString()
          });
          const response = new Response(blob, { headers });
          await cache.put(url, response);
        } catch (e) {
          console.warn('Cache put failed', e);
        }
      }

      async function loadVideo(url) {
        spinner.classList.add('show');
        video.src = '';
        if (window.blobUrl) {
          URL.revokeObjectURL(window.blobUrl);
          window.blobUrl = null;
        }
        try {
          // Try to get from cache first
          let cachedResponse = await getCachedVideo(url);
          if (cachedResponse) {
            const blob = await cachedResponse.blob();
            window.blobUrl = URL.createObjectURL(blob);
            video.src = window.blobUrl;
            video.load();
            video.play().catch(() => {});
            spinner.classList.remove('show');
            return;
          }

          // Not cached, fetch and cache
          const resp = await fetch(url, { mode: 'cors' });
          if (!resp.ok) throw new Error();
          const blob = await resp.blob();
          // Cache the blob
          await cacheVideo(url, blob);
          window.blobUrl = URL.createObjectURL(blob);
          video.src = window.blobUrl;
          video.load();
          video.play().catch(() => {});
        } catch (e) {
          toastMsg('‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü, ‡§°‡§æ‡§Ø‡§∞‡•á‡§ï‡•ç‡§ü ‡§≤‡§ø‡§Ç‡§ï ‡§ï‡•ã‡§∂‡§ø‡§∂');
          video.src = url; // fallback
          video.load();
          video.play().catch(() => {});
        } finally {
          spinner.classList.remove('show');
        }
      }

      // ---------- LOAD DATA ----------
      async function loadData() {
        try {
          const res = await fetch('https://storytv.btfcompanystorage.workers.dev/data');
          if (!res.ok) throw new Error();
          D = await res.json();
        } catch {
          toastMsg('‡§°‡•á‡§ü‡§æ ‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•Å‡§Ü');
          return;
        }
        show = D.shows.find(s => s.id === sid);
        if (!show) {
          toastMsg('‡§∂‡•ã ‡§®‡§π‡•Ä‡§Ç ‡§Æ‡§ø‡§≤‡§æ');
          return;
        }
        // favicon
        if (D.site?.favicon_url) {
          let link = document.querySelector("link[rel='icon']") || document.createElement('link');
          link.rel = 'icon';
          link.href = D.site.favicon_url;
          document.head.appendChild(link);
        }
        document.getElementById('show-title').textContent = show.title || 'Show';
        renderPlaylist();
        loadEpisode(currentEpIndex);
      }

      function loadEpisode(index) {
        const ep = show.episodes[index];
        if (!ep) return;

        // update info
        document.getElementById('ep-title').textContent = ep.title || `‡§è‡§™‡§ø‡§∏‡•ã‡§° ${ep.ep}`;
        document.getElementById('ep-meta').innerHTML = `Ep ${ep.ep} ¬∑ ${ep.duration} ¬∑ ${show.language}`;
        document.title = `Ep ${ep.ep} ‚Äì ${show.title} | BTF TV`;

        // load video with cache
        loadVideo(ep.video_url);

        // update playlist active
        document.querySelectorAll('.drawer-item').forEach((item, i) => {
          if (i === index) item.classList.add('active');
          else item.classList.remove('active');
        });

        // restore progress
        const key = sid + '_' + index;
        const saved = historyData[key]?.t || 0;
        if (saved > 3) {
          const onCanPlay = () => {
            video.currentTime = saved;
            video.removeEventListener('canplay', onCanPlay);
          };
          video.addEventListener('canplay', onCanPlay);
        }

        // hide next overlay
        hideNextOverlay();
      }

      // ---------- PLAYLIST DRAWER ----------
      function renderPlaylist() {
        let html = '';
        show.episodes.forEach((ep, i) => {
          const activeClass = (i === currentEpIndex) ? 'active' : '';
          const lockClass = ep.is_free ? '' : 'locked';
          html += `<div class="drawer-item ${activeClass} ${lockClass}" data-index="${i}">
            <i class="fas fa-play-circle"></i> Ep ${ep.ep}
          </div>`;
        });
        playlistDrawer.innerHTML = html;

        // attach click
        document.querySelectorAll('.drawer-item').forEach(item => {
          item.addEventListener('click', (e) => {
            const idx = parseInt(item.dataset.index, 10);
            if (idx === currentEpIndex) {
              playlistDrawer.classList.remove('open');
              return;
            }
            const ep = show.episodes[idx];
            if (!ep.is_free) {
              toastMsg('üîí ‡§Ø‡§π ‡§è‡§™‡§ø‡§∏‡•ã‡§° GOLD ‡§∏‡§¨‡•ç‡§∏‡§ï‡•ç‡§∞‡§æ‡§á‡§¨‡§∞‡•ç‡§∏ ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡•à');
              return;
            }
            if (autoNextTimer) clearTimeout(autoNextTimer);
            hideNextOverlay();
            currentEpIndex = idx;
            loadEpisode(idx);
            playlistDrawer.classList.remove('open');
          });
        });
      }

      playlistToggle.addEventListener('click', () => {
        playlistDrawer.classList.toggle('open');
      });

      // close drawer if tap outside
      document.querySelector('.video-wrapper').addEventListener('click', (e) => {
        if (playlistDrawer.classList.contains('open') && !e.target.closest('.playlist-drawer') && !e.target.closest('.playlist-btn')) {
          playlistDrawer.classList.remove('open');
        }
      });

      // ---------- GESTURES: DOUBLE TAP, SINGLE TAP, VERTICAL SWIPE ----------
      document.querySelector('.video-wrapper').addEventListener('touchstart', (e) => {
        const touch = e.touches[0];
        touchStartY = touch.clientY;
        touchStartX = touch.clientX;
        touchStartTime = Date.now();
      }, { passive: true });

      document.querySelector('.video-wrapper').addEventListener('touchend', (e) => {
        const touch = e.changedTouches[0];
        const deltaY = touch.clientY - touchStartY;
        const deltaX = touch.clientX - touchStartX;
        const timeDiff = Date.now() - touchStartTime;
        const now = Date.now();

        // Double tap detection (within 300ms)
        if (now - lastTapTime < DOUBLE_TAP_DELAY && Math.abs(deltaX) < 30 && Math.abs(deltaY) < 30) {
          // Double tap ‚Äì skip based on side
          const half = window.innerWidth / 2;
          if (touch.clientX < half) {
            skip(-10);
            showCenterIcon('backward');
          } else {
            skip(10);
            showCenterIcon('forward');
          }
          lastTapTime = 0; // reset to avoid triple tap
          return;
        }

        // Check if it's a swipe (significant movement)
        if (Math.abs(deltaY) > SWIPE_THRESHOLD && Math.abs(deltaY) > Math.abs(deltaX)) {
          // vertical swipe
          if (deltaY < 0) { // swipe up -> next episode
            changeEpisode(1);
          } else { // swipe down -> previous episode
            changeEpisode(-1);
          }
        } else if (Math.abs(deltaX) < 20 && Math.abs(deltaY) < 20 && timeDiff < 300) {
          // Single tap (no movement) ‚Äì toggle play/pause and show/hide controls
          togglePlayPause();
        }

        lastTapTime = now;
      }, { passive: true });

      function skip(seconds) {
        video.currentTime = Math.max(0, Math.min(video.duration || 0, video.currentTime + seconds));
      }

      function changeEpisode(direction) {
        const newIndex = currentEpIndex + direction;
        if (newIndex < 0 || newIndex >= show.episodes.length) {
          toastMsg(direction > 0 ? '‡§Ü‡§ñ‡§ø‡§∞‡•Ä ‡§è‡§™‡§ø‡§∏‡•ã‡§° ‡§π‡•à' : '‡§™‡§π‡§≤‡§æ ‡§è‡§™‡§ø‡§∏‡•ã‡§° ‡§π‡•à');
          return;
        }
        const ep = show.episodes[newIndex];
        if (!ep.is_free) {
          toastMsg('üîí ‡§Ø‡§π ‡§è‡§™‡§ø‡§∏‡•ã‡§° GOLD ‡§π‡•à');
          return;
        }
        if (autoNextTimer) clearTimeout(autoNextTimer);
        hideNextOverlay();
        currentEpIndex = newIndex;
        loadEpisode(currentEpIndex);
      }

      function togglePlayPause() {
        if (video.paused) {
          video.play().catch(() => {});
          showCenterIcon('play');
        } else {
          video.pause();
          showCenterIcon('pause');
        }
        // Also toggle controls visibility
        const topBar = document.querySelector('.top-bar');
        const bottomBar = document.querySelector('.bottom-bar');
        if (topBar.style.opacity === '0') {
          topBar.style.opacity = '1';
          bottomBar.style.opacity = '1';
        } else {
          topBar.style.opacity = '0';
          bottomBar.style.opacity = '0';
        }
      }

      function showCenterIcon(action) {
        if (action === 'play') centerIcon.innerHTML = '<i class="fas fa-play"></i>';
        else if (action === 'pause') centerIcon.innerHTML = '<i class="fas fa-pause"></i>';
        else if (action === 'backward') centerIcon.innerHTML = '<i class="fas fa-backward"></i> 10';
        else if (action === 'forward') centerIcon.innerHTML = '<i class="fas fa-forward"></i> 10';
        centerIcon.classList.add('visible');
        setTimeout(() => centerIcon.classList.remove('visible'), 500);
      }

      // ---------- PROGRESS BAR ----------
      progressContainer.addEventListener('touchstart', (e) => {
        isDraggingProgress = true;
        updateProgressFromEvent(e.touches[0]);
        e.preventDefault();
      }, { passive: false });

      document.addEventListener('touchmove', (e) => {
        if (isDraggingProgress) {
          updateProgressFromEvent(e.touches[0]);
          e.preventDefault();
        }
      }, { passive: false });

      document.addEventListener('touchend', (e) => {
        if (isDraggingProgress) {
          isDraggingProgress = false;
          if (e.changedTouches[0]) {
            updateProgressFromEvent(e.changedTouches[0], true); // set video time
          }
        }
      });

      function updateProgressFromEvent(touch, setVideo = false) {
        const rect = progressContainer.getBoundingClientRect();
        let pos = (touch.clientX - rect.left) / rect.width;
        pos = Math.max(0, Math.min(1, pos));
        progressFill.style.width = (pos * 100) + '%';
        progressHandle.style.left = (pos * 100) + '%';
        if (setVideo && video.duration) {
          video.currentTime = pos * video.duration;
        } else {
          if (video.duration) {
            currentTimeSpan.textContent = fmtTime(pos * video.duration);
          }
        }
      }

      // video timeupdate
      video.addEventListener('timeupdate', () => {
        if (!isDraggingProgress && video.duration) {
          const pct = (video.currentTime / video.duration) * 100;
          progressFill.style.width = pct + '%';
          progressHandle.style.left = pct + '%';
          currentTimeSpan.textContent = fmtTime(video.currentTime);
        }
        // save progress
        const key = sid + '_' + currentEpIndex;
        historyData[key] = { sid, ei: currentEpIndex, t: Math.round(video.currentTime), d: Math.round(video.duration) };
        try { localStorage.setItem('btftv_h', JSON.stringify(historyData)); } catch { }
      });

      video.addEventListener('loadedmetadata', () => {
        durationSpan.textContent = fmtTime(video.duration);
      });

      // ---------- VIDEO EVENTS ----------
      video.addEventListener('play', () => {
        showCenterIcon('pause');
        if (hideControlsTimer) clearTimeout(hideControlsTimer);
        hideControlsTimer = setTimeout(() => {
          document.querySelector('.top-bar').style.opacity = '0';
          document.querySelector('.bottom-bar').style.opacity = '0';
        }, 2000);
      });

      video.addEventListener('pause', () => {
        showCenterIcon('play');
        document.querySelector('.top-bar').style.opacity = '1';
        document.querySelector('.bottom-bar').style.opacity = '1';
        if (hideControlsTimer) clearTimeout(hideControlsTimer);
      });

      video.addEventListener('waiting', () => spinner.classList.add('show'));
      video.addEventListener('canplay', () => spinner.classList.remove('show'));

      video.addEventListener('ended', () => {
        if (currentEpIndex < show.episodes.length - 1) {
          const nextEp = show.episodes[currentEpIndex + 1];
          nextTitle.textContent = `Ep ${nextEp.ep}: ${nextEp.title}`;
          nextOverlay.classList.add('show');
          autoNextTimer = setTimeout(() => {
            if (nextEp.is_free) {
              currentEpIndex++;
              loadEpisode(currentEpIndex);
            } else {
              toastMsg('üîí ‡§Ö‡§ó‡§≤‡§æ ‡§è‡§™‡§ø‡§∏‡•ã‡§° GOLD ‡§π‡•à');
              hideNextOverlay();
            }
          }, 5000);
        }
      });

      document.getElementById('next-cancel').addEventListener('click', () => {
        hideNextOverlay();
        if (autoNextTimer) clearTimeout(autoNextTimer);
      });
      document.getElementById('next-go').addEventListener('click', () => {
        if (autoNextTimer) clearTimeout(autoNextTimer);
        if (currentEpIndex < show.episodes.length - 1) {
          const nextEp = show.episodes[currentEpIndex + 1];
          if (!nextEp.is_free) {
            toastMsg('üîí GOLD ‡§ö‡§æ‡§π‡§ø‡§è');
            hideNextOverlay();
            return;
          }
          currentEpIndex++;
          loadEpisode(currentEpIndex);
        }
      });

      function hideNextOverlay() {
        nextOverlay.classList.remove('show');
        if (autoNextTimer) clearTimeout(autoNextTimer);
      }

      // back button
      document.getElementById('back-btn').addEventListener('click', () => {
        if (window.blobUrl) URL.revokeObjectURL(window.blobUrl);
        history.back();
      });

      // start
      loadData();
    })();
  </script>
</body>
</html>


Is me kahi bhi click karo pause ho ja rha hai video usey fix karo click karne pe details dikhe , tab waha pause ya play , achhe se apne set kar do aur maine har vidoe ka alag alag id chahta hu ek hi url parameter me puri video chal rhe hai ye sahi nhi hai har video apna khul ka url parameter banaye , cache ke sath youtube aur instagram jaisa aur smooth transitions ho scroll karne pe aur har device ka alag alag cache aur cookies create ho, har user ka , best banana, achhe se full heavy aur best

‡§Ø‡§π‡§æ‡§Å ‡§Ü‡§™‡§ï‡•á ‡§∏‡§≠‡•Ä issues fix ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ code ‡§π‡•à‡•§ ‡§π‡§∞ video ‡§ï‡§æ unique URL, smooth transitions, per-device cache, proper controls ‡§î‡§∞ best UX ‡§∏‡§¨ ‡§ï‡•Å‡§õ add ‡§ï‡§ø‡§Ø‡§æ ‡§π‡•à:

```html
<!DOCTYPE html>
<html lang="hi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>BTF TV ‚Äì Reels Player</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      -webkit-user-select: none;
      -webkit-touch-callout: none;
    }
    body {
      font-family: 'Poppins', sans-serif;
      background: black;
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      position: fixed;
      inset: 0;
      color: white;
    }
    #player {
      position: relative;
      width: 100%;
      height: 100%;
      background: black;
    }
    .video-wrapper {
      position: relative;
      width: 100%;
      height: 100%;
      background: black;
      transition: opacity 0.3s ease;
    }
    video {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      background: black;
      transition: opacity 0.3s ease;
    }
    /* Main gesture areas - exclude progress bar area */
    .main-gesture {
      position: absolute;
      inset: 0;
      z-index: 10;
      pointer-events: none;
    }
    .main-gesture > div {
      pointer-events: auto;
    }
    .left-gesture, .right-gesture {
      position: absolute;
      top: 0;
      width: 50%;
      height: 100%;
    }
    .left-gesture { left: 0; }
    .right-gesture { right: 0; }
    
    /* Top gesture area (20% from top) */
    .top-gesture {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 20%;
      z-index: 12;
    }
    
    /* Bottom gesture area (progress bar + 20%) */
    .bottom-safe {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 25%;
      z-index: 12;
    }
    
    /* top bar */
    .top-bar {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 16px 16px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      background: linear-gradient(to bottom, rgba(0,0,0,0.8) 0%, transparent 100%);
      z-index: 20;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    .top-bar.show { opacity: 1; }
    .top-bar * { pointer-events: auto; }
    
    .back-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(34,34,34,0.9);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,255,255,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: white;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .back-btn:active { background: #FFD700; color: black; transform: scale(0.95); }
    
    .show-title {
      font-family: 'Bebas Neue', cursive;
      font-size: 1.5rem;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.8);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }
    
    .playlist-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      background: rgba(34,34,34,0.9);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255,215,0,0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: #FFD700;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-left: auto;
    }
    .playlist-btn:active { background: #FFD700; color: black; transform: scale(0.95); }
    
    /* bottom bar */
    .bottom-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 24px 16px 32px;
      background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, transparent 100%);
      z-index: 20;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    .bottom-bar.show { opacity: 1; }
    .bottom-bar * { pointer-events: auto; }
    
    .episode-info {
      margin-bottom: 16px;
    }
    .episode-title {
      font-family: 'Bebas Neue', cursive;
      font-size: 2rem;
      color: #FFD700;
      line-height: 1.2;
      margin-bottom: 4px;
    }
    .episode-meta {
      font-size: 0.8rem;
      color: #ccc;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    
    .progress-container {
      width: 100%;
      height: 6px;
      display: flex;
      align-items: center;
      cursor: pointer;
      margin-bottom: 8px;
      border-radius: 3px;
    }
    .progress-track {
      flex: 1;
      height: 6px;
      background: rgba(255,255,255,0.3);
      border-radius: 3px;
      position: relative;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #FFD700, #FFA500);
      border-radius: 3px;
      width: 0%;
      transition: width 0.1s ease;
      pointer-events: none;
    }
    .progress-handle {
      width: 20px;
      height: 20px;
      background: #FFD700;
      border-radius: 50%;
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      left: 0%;
      opacity: 0;
      transition: all 0.2s ease;
      box-shadow: 0 4px 12px rgba(255,215,0,0.6);
    }
    .progress-container:hover .progress-handle,
    .progress-container.active .progress-handle { opacity: 1; }
    
    .time-indicator {
      display: flex;
      justify-content: space-between;
      font-size: 0.75rem;
      color: #ddd;
      font-weight: 500;
    }
    
    /* Playlist drawer */
    .playlist-drawer {
      position: fixed;
      right: 0;
      top: 0;
      bottom: 0;
      width: 260px;
      background: rgba(15,15,15,0.99);
      backdrop-filter: blur(20px);
      border-left: 2px solid #333;
      z-index: 100;
      transform: translateX(100%);
      transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      padding: 24px 0;
      overflow-y: auto;
      box-shadow: -4px 0 20px rgba(0,0,0,0.5);
    }
    .playlist-drawer.open { transform: translateX(0); }
    
    .drawer-header {
      padding: 0 24px 20px;
      border-bottom: 1px solid #333;
      margin-bottom: 16px;
    }
    .drawer-title {
      font-family: 'Bebas Neue', cursive;
      font-size: 1.4rem;
      color: #FFD700;
      margin-bottom: 4px;
    }
    .drawer-close {
      position: absolute;
      top: 24px;
      right: 24px;
      width: 36px;
      height: 36px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      cursor: pointer;
      font-size: 1rem;
    }
    .drawer-close:active { background: #FFD700; color: black; }
    
    .drawer-item {
      padding: 18px 24px;
      border-bottom: 1px solid rgba(255,255,255,0.05);
      display: flex;
      align-items: center;
      gap: 16px;
      cursor: pointer;
      color: white;
      font-weight: 500;
      transition: all 0.2s ease;
      position: relative;
    }
    .drawer-item:hover {
      background: rgba(255,215,0,0.1);
      border-left: 4px solid #FFD700;
    }
    .drawer-item.active {
      background: rgba(255,215,0,0.15);
      border-left: 4px solid #FFD700;
    }
    .drawer-item.locked {
      color: #888;
      cursor: not-allowed;
    }
    .drawer-item.locked::after {
      content: '\f023';
      font-family: 'Font Awesome 6 Free';
      font-weight: 900;
      margin-left: auto;
      font-size: 1rem;
      color: #FFD700;
    }
    .drawer-item i {
      width: 28px;
      color: #FFD700;
      font-size: 1.2rem;
    }
    
    /* Next episode overlay */
    .next-overlay {
      position: absolute;
      bottom: 140px;
      left: 24px;
      right: 24px;
      background: rgba(20,20,20,0.98);
      backdrop-filter: blur(20px);
      border-radius: 24px;
      padding: 20px 28px;
      border: 1px solid rgba(255,215,0,0.4);
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 35;
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      pointer-events: none;
    }
    .next-overlay.show {
      transform: translateY(0);
      opacity: 1;
      pointer-events: auto;
    }
    
    .next-info {
      display: flex;
      flex-direction: column;
      flex: 1;
    }
    .next-label {
      font-size: 0.75rem;
      color: #FFD700;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }
    .next-title {
      font-weight: 600;
      font-size: 1.1rem;
      color: white;
    }
    
    .next-actions {
      display: flex;
      gap: 20px;
      margin-left: 16px;
    }
    .next-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .next-btn:active {
      background: #FFD700;
      color: black;
      transform: scale(0.95);
    }
    
    /* Center play/pause button */
    .center-play {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80px;
      height: 80px;
      background: rgba(255,215,0,0.95);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 2.2rem;
      color: black;
      z-index: 40;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      box-shadow: 0 8px 32px rgba(255,215,0,0.4);
    }
    .center-play.show {
      opacity: 1;
      pointer-events: auto;
    }
    .center-play:active { transform: translate(-50%, -50%) scale(0.9); }
    
    /* Skip icons */
    .skip-icon {
      position: absolute;
      top: 50%;
      width: 60px;
      height: 60px;
      background: rgba(0,0,0,0.7);
      backdrop-filter: blur(12px);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: #FFD700;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      border: 2px solid rgba(255,215,0,0.3);
    }
    .skip-left { left: 40px; transform: translateY(-50%); }
    .skip-right { right: 40px; transform: translateY(-50%); }
    .skip-icon.show { opacity: 1; }
    
    /* Loading spinner */
    #spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255,255,255,0.1);
      border-top-color: #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    #spinner.show { opacity: 1; }
    @keyframes spin { to { transform: translate(-50%, -50%) rotate(360deg); } }
    
    /* Toast */
    #toast {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: rgba(26,26,26,0.95);
      backdrop-filter: blur(12px);
      color: white;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 12px 24px;
      border-radius: 24px;
      font-size: 0.9rem;
      font-weight: 600;
      z-index: 999;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      white-space: nowrap;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    }
    #toast.on { 
      opacity: 1; 
      transform: translateX(-50%) translateY(0); 
    }
    
    /* Backdrop overlay */
    .backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      z-index: 90;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }
    .backdrop.show {
      opacity: 1;
      visibility: visible;
    }
    
    /* Smooth fade transitions */
    .fade-in { animation: fadeIn 0.4s ease; }
    .fade-out { animation: fadeOut 0.4s ease; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes fadeOut { from { opacity: 1; } to { opacity: 0; } }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="player">
    <div class="video-wrapper" id="videoWrapper">
      <video id="video" playsinline preload="auto" disablepictureinpicture></video>

      <!-- Gesture areas -->
      <div class="main-gesture">
        <div class="left-gesture" id="leftGesture"></div>
        <div class="right-gesture" id="rightGesture"></div>
      </div>
      
      <!-- Top gesture area -->
      <div class="top-gesture" id="topGesture"></div>
      
      <!-- Bottom safe area -->
      <div class="bottom-safe" id="bottomSafe"></div>

      <!-- Top bar -->
      <div class="top-bar" id="topBar">
        <button class="back-btn" id="backBtn"><i class="fas fa-arrow-left"></i></button>
        <div class="show-title" id="showTitle">Loading...</div>
        <button class="playlist-btn" id="playlistToggle"><i class="fas fa-list-ul"></i></button>
      </div>

      <!-- Bottom bar -->
      <div class="bottom-bar" id="bottomBar">
        <div class="episode-info">
          <div class="episode-title" id="epTitle">Loading...</div>
          <div class="episode-meta" id="epMeta"></div>
        </div>
        <div class="progress-container" id="progressContainer">
          <div class="progress-track">
            <div class="progress-fill" id="progressFill"></div>
            <div class="progress-handle" id="progressHandle"></div>
          </div>
        </div>
        <div class="time-indicator">
          <span id="currentTime">0:00</span>
          <span id="duration">--:--</span>
        </div>
      </div>

      <!-- Skip icons -->
      <div class="skip-icon skip-left" id="skipLeft"><i class="fas fa-backward"></i> 10s</div>
      <div class="skip-icon skip-right" id="skipRight"><i class="fas fa-forward"></i> 10s</div>

      <!-- Center play button -->
      <div class="center-play" id="centerPlay"><i class="fas fa-play"></i></div>

      <!-- Spinner -->
      <div id="spinner"></div>
    </div>
  </div>

  <!-- Playlist drawer -->
  <div class="playlist-drawer" id="playlistDrawer">
    <div class="drawer-header">
      <h3 class="drawer-title" id="drawerTitle">Playlist</h3>
      <button class="drawer-close" id="drawerClose"><i class="fas fa-times"></i></button>
    </div>
  </div>

  <!-- Backdrop -->
  <div class="backdrop" id="backdrop"></div>

  <!-- Toast -->
  <div id="toast"></div>

  <script>
    (function() {
      'use strict';

      // ========== DEVICE/PER-USER IDENTIFICATION ==========
      function getDeviceId() {
        let deviceId = localStorage.getItem('btftv_device_id');
        if (!deviceId) {
          deviceId = 'dev_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
          localStorage.setItem('btftv_device_id', deviceId);
        }
        return deviceId;
      }

      const DEVICE_ID = getDeviceId();
      const CACHE_NAME = `btftv-videos-${DEVICE_ID.slice(0, 8)}`;
      const HISTORY_KEY = `btftv_history_${DEVICE_ID.slice(0, 8)}`;
      const SESSION_KEY = `btftv_session_${DEVICE_ID.slice(0, 8)}`;
      
      const CACHE_EXPIRY = 2 * 60 * 60 * 1000; // 2 hours per device
      const SESSION_DURATION = 24 * 60 * 60 * 1000; // 24 hours

      // ========== URL HANDLING - UNIQUE PER VIDEO ==========
      const urlParams = new URLSearchParams(location.search);
      const videoId = urlParams.get('v'); // ?v=unique_video_id
      
      if (!videoId) {
        toastMsg('‚ùå Invalid video ID');
        setTimeout(() => window.location.href = 'index.html', 1500);
        return;
      }

      // ========== GLOBALS ==========
      let data = null;
      let currentVideo = null;
      let isDraggingProgress = false;
      let controlsVisible = false;
      let hideControlsTimer = null;
      let touchStartX = 0, touchStartY = 0, touchStartTime = 0;
      let lastTapTime = 0;
      const DOUBLE_TAP_DELAY = 350;
      const SWIPE_THRESHOLD = 60;

      // DOM Elements
      const elements = {
        video: document.getElementById('video'),
        videoWrapper: document.getElementById('videoWrapper'),
        topBar: document.getElementById('topBar'),
        bottomBar: document.getElementById('bottomBar'),
        centerPlay: document.getElementById('centerPlay'),
        playlistDrawer: document.getElementById('playlistDrawer'),
        backdrop: document.getElementById('backdrop'),
        playlistToggle: document.getElementById('playlistToggle'),
        backBtn: document.getElementById('backBtn'),
        drawerClose: document.getElementById('drawerClose'),
        progressContainer: document.getElementById('progressContainer'),
        progressFill: document.getElementById('progressFill'),
        progressHandle: document.getElementById('progressHandle'),
        currentTime: document.getElementById('currentTime'),
        duration: document.getElementById('duration'),
        epTitle: document.getElementById('epTitle'),
        epMeta: document.getElementById('epMeta'),
        showTitle: document.getElementById('showTitle'),
        drawerTitle: document.getElementById('drawerTitle'),
        spinner: document.getElementById('spinner'),
        skipLeft: document.getElementById('skipLeft'),
        skipRight: document.getElementById('skipRight'),
        toast: document.getElementById('toast'),
        leftGesture: document.getElementById('leftGesture'),
        rightGesture: document.getElementById('rightGesture'),
        topGesture: document.getElementById('topGesture'),
        bottomSafe: document.getElementById('bottomSafe')
      };

      // ========== UTILITY FUNCTIONS ==========
      function fmtTime(seconds) {
        if (!seconds || isNaN(seconds)) return '0:00';
        const m = Math.floor(seconds / 60);
        const s = Math.floor(seconds % 60);
        return `${m}:${s.toString().padStart(2, '0')}`;
      }

      function toastMsg(msg, duration = 2500) {
        elements.toast.textContent = msg;
        elements.toast.classList.add('on');
        setTimeout(() => elements.toast.classList.remove('on'), duration);
      }

      function showControls() {
        controlsVisible = true;
        elements.topBar.classList.add('show');
        elements.bottomBar.classList.add('show');
        if (hideControlsTimer) clearTimeout(hideControlsTimer);
        hideControlsTimer = setTimeout(hideControls, 4000);
      }

      function hideControls() {
        controlsVisible = false;
        elements.topBar.classList.remove('show');
        elements.bottomBar.classList.remove('show');
        if (hideControlsTimer) clearTimeout(hideControlsTimer);
      }

      function toggleControls() {
        if (controlsVisible) hideControls();
        else showControls();
      }

      function setCenterIcon(icon) {
        elements.centerPlay.innerHTML = icon;
        elements.centerPlay.classList.add('show');
        setTimeout(() => elements.centerPlay.classList.remove('show'), 600);
      }

      // ========== ADVANCED CACHE SYSTEM ==========
      async function getCachedVideo(url) {
        try {
          const cache = await caches.open(CACHE_NAME);
          const response = await cache.match(url);
          if (!response) return null;
          
          const cachedTime = response.headers.get('x-cached-time');
          if (cachedTime && (Date.now() - parseInt(cachedTime)) < CACHE_EXPIRY) {
            return response;
          }
          await cache.delete(url);
          return null;
        } catch (e) {
          console.warn('Cache check failed:', e);
          return null;
        }
      }

      async function cacheVideo(url, blob) {
        try {
          const cache = await caches.open(CACHE_NAME);
          const headers = new Headers({
            'Content-Type': 'video/mp4',
            'x-cached-time': Date.now().toString(),
            'x-device-id': DEVICE_ID
          });
          const response = new Response(blob, { headers });
          await cache.put(url, response);
        } catch (e) {
          console.warn('Cache save failed:', e);
        }
      }

      async function loadVideoSmooth(url) {
        elements.spinner.classList.add('show');
        elements.video.style.opacity = '0';
        
        // Cleanup old blob
        if (window.currentBlobUrl) {
          URL.revokeObjectURL(window.currentBlobUrl);
        }

        try {
          // Try cache first
          let cachedResponse = await getCachedVideo(url);
          let blob;
          
          if (cachedResponse) {
            blob = await cachedResponse.blob();
          } else {
            // Fetch and cache
            const response = await fetch(url, { 
              mode: 'cors',
              cache: 'no-cache'
            });
            if (!response.ok) throw new Error('Video fetch failed');
            blob = await response.blob();
            await cacheVideo(url, blob);
          }

          window.currentBlobUrl = URL.createObjectURL(blob);
          elements.video.src = window.currentBlobUrl;
          
          // Smooth transition
          elements.video.addEventListener('loadeddata', () => {
            elements.video.style.opacity = '1';
            elements.spinner.classList.remove('show');
          }, { once: true });
          
          elements.video.load();
          
        } catch (error) {
          toastMsg('‚ùå ‡§µ‡•Ä‡§°‡§ø‡§Ø‡•ã ‡§≤‡•ã‡§° ‡§®‡§π‡•Ä‡§Ç ‡§π‡•ã ‡§∏‡§ï‡§æ');
          elements.video.src = url; // Fallback
          elements.video.style.opacity = '1';
          elements.spinner.classList.remove('show');
        }
      }

      // ========== GESTURES - PERFECT CONTROL ==========
      function setupGestures() {
        let touchStart = { x: 0, y: 0, time: 0 };

        // Single/Double tap detection
        function handleTap(touch) {
          const now = Date.now();
          const deltaX = Math.abs(touch.clientX - touchStart.x);
          const deltaY = Math.abs(touch.clientY - touchStart.y);
          
          if (now - lastTapTime < DOUBLE_TAP_DELAY && deltaX < 40 && deltaY < 40) {
            // Double tap - Skip
            if (touch.clientX < window.innerWidth / 2) {
              // Left side - rewind
              const newTime = Math.max(0, elements.video.currentTime - 10);
              elements.video.currentTime = newTime;
              elements.skipLeft.classList.add('show');
              setTimeout(() => elements.skipLeft.classList.remove('show'), 400);
            } else {
              // Right side - forward
              const newTime = Math.min(elements.video.duration || 0, elements.video.currentTime + 10);
              elements.video.currentTime = newTime;
              elements.skipRight.classList.add('show');
              setTimeout(() => elements.skipRight.classList.remove('show'), 400);
            }
            lastTapTime = 0;
            return;
          }

          // Single tap - toggle controls only
          toggleControls();
          lastTapTime = now;
        }

        // Touch events
        [elements.leftGesture, elements.rightGesture, elements.topGesture].forEach(el => {
          el.addEventListener('touchstart', (e) => {
            touchStart = {
              x: e.touches[0].clientX,
              y: e.touches[0].clientY,
              time: Date.now()
            };
          }, { passive: true });

          el.addEventListener('touchend', (e) => {
            const touch = e.changedTouches[0];
            const timeDiff = Date.now() - touchStart.time;
            
            if (timeDiff < 300 && Math.abs(touch.clientX - touchStart.x) < 30 && 
                Math.abs(touch.clientY - touchStart.y) < 30) {
              handleTap(touch);
            }
          }, { passive: true });
        });

        // Bottom safe area - no action
        elements.bottomSafe.style.pointerEvents = 'none';
      }

      // ========== PROGRESS BAR ==========
      function setupProgressBar() {
        let isDragging = false;

        function updateProgressFromEvent(clientX, commit = false) {
          const rect = elements.progressContainer.getBoundingClientRect();
          let pos = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
          
          elements.progressFill.style.width = `${pos * 100}%`;
          elements.progressHandle.style.left = `${pos * 100}%`;
          
          if (commit && elements.video.duration) {
            elements.video.currentTime = pos * elements.video.duration;
          } else if (elements.video.duration) {
            elements.currentTime.textContent = fmtTime(pos * elements.video.duration);
          }
        }

        elements.progressContainer.addEventListener('touchstart', (e) => {
          isDragging = true;
          elements.progressContainer.classList.add('active');
          updateProgressFromEvent(e.touches[0].clientX);
          e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
          if (isDragging) {
            updateProgressFromEvent(e.touches[0].clientX);
            e.preventDefault();
          }
        }, { passive: false });

        document.addEventListener('touchend', () => {
          if (isDragging) {
            isDragging = false;
            elements.progressContainer.classList.remove('active');
            updateProgressFromEvent(e.changedTouches[0]?.clientX || 0, true);
          }
        }, { passive: false });
      }

      // ========== LOAD DATA & VIDEO ==========
      async function loadData() {
        try {
          const response = await fetch('https://storytv.btfcompanystorage.workers.dev/data');
          if (!response.ok) throw new Error('Data fetch failed');
          data = await response.json();
          
          // Find specific video by ID
          const videoData = data.videos?.find(v => v.id === videoId) || 
                          data.shows?.flatMap(s => s.episodes.map((ep, i) => ({...ep, showId: s.id, showTitle: s.title, index: i})))
                            .find(ep => ep.id === videoId);
          
          if (!videoData) {
            toastMsg('‚ùå Video not found');
            setTimeout(() => history.back(), 2000);
            return;
          }

          currentVideo = videoData;
          
          // Update UI
          document.title = `${currentVideo.title || `Episode ${currentVideo.ep}`} | BTF TV`;
          elements.showTitle.textContent = currentVideo.showTitle || 'BTF TV';
          elements.epTitle.textContent = currentVideo.title || `Episode ${currentVideo.ep}`;
          elements.epMeta.innerHTML = `
            ${currentVideo.ep ? `Ep ${currentVideo.ep}` : ''} 
            ¬∑ ${currentVideo.duration || 'N/A'} 
            ¬∑ ${currentVideo.language || 'Hindi'}
          `;
          elements.drawerTitle.textContent = currentVideo.showTitle || 'Playlist';

          // Load video with smooth transition
          await loadVideoSmooth(currentVideo.video_url);
          
          // Restore progress
          const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '{}');
          const progressKey = `${videoId}_${DEVICE_ID}`;
          const savedProgress = history[progressKey];
          
          if (savedProgress && savedProgress.time > 5 && savedProgress.time < savedProgress.duration - 10) {
            elements.video.addEventListener('loadeddata', () => {
              elements.video.currentTime = savedProgress.time;
            }, { once: true });
          }

        } catch (error) {
          toastMsg('‚ùå Data load failed');
          console.error(error);
        }
      }

      // ========== VIDEO EVENTS ==========
      function setupVideoEvents() {
        // Time update
        elements.video.addEventListener('timeupdate', () => {
          if (!isDraggingProgress && elements.video.duration) {
            const pct = (elements.video.currentTime / elements.video.duration) * 100;
            elements.progressFill.style.width = `${pct}%`;
            elements.progressHandle.style.left = `${pct}%`;
            elements.currentTime.textContent = fmtTime(elements.video.currentTime);
          }

          // Auto-save progress every 10 seconds
          if (Math.floor(elements.video.currentTime) % 10 === 0) {
            saveProgress();
          }
        });

        elements.video.addEventListener('loadedmetadata', () => {
          elements.duration.textContent = fmtTime(elements.video.duration);
        });

        // Play/Pause
        elements.video.addEventListener('play', () => {
          setCenterIcon('<i class="fas fa-pause"></i>');
          showControls();
        });

        elements.video.addEventListener('pause', () => {
          setCenterIcon('<i class="fas fa-play"></i>');
          showControls();
        });

        // Loading states
        elements.video.addEventListener('waiting', () => {
          elements.spinner.classList.add('show');
        });

        elements.video.addEventListener('canplay', () => {
          elements.spinner.classList.remove('show');
        });

        // Video ended
        elements.video.addEventListener('ended', () => {
          setCenterIcon('<i class="fas fa-redo"></i>');
          showControls();
        });
      }

      function saveProgress() {
        try {
          const history = JSON.parse(localStorage.getItem(HISTORY_KEY) || '{}');
          const progressKey = `${videoId}_${DEVICE_ID}`;
          
          history[progressKey] = {
            videoId,
            deviceId: DEVICE_ID,
            time: Math.round(elements.video.currentTime),
            duration: Math.round(elements.video.duration),
            title: currentVideo.title,
            updated: Date.now()
          };
          
          localStorage.setItem(HISTORY_KEY, JSON.stringify(history));
        } catch (e) {
          console.warn('Progress save failed:', e);
        }
      }

      // ========== PLAYLIST ==========
      function renderPlaylist() {
        if (!data) return;
        
        const show = data.shows?.find(s => s.id === currentVideo?.showId);
        if (!show) return;

        let html = '';
        show.episodes.forEach((ep, i) => {
          const isActive = ep.id === videoId;
          const isLocked = !ep.is_free;
          const itemClass = `drawer-item ${isActive ? 'active' : ''} ${isLocked ? 'locked' : ''}`;
          
          html += `
            <div class="${itemClass}" data-video-id="${ep.id}" data-show-id="${show.id}">
              <i class="fas fa-play-circle"></i>
              Ep ${ep.ep}${ep.title ? `: ${ep.title}` : ''}
            </div>
          `;
        });

        elements.playlistDrawer.innerHTML = `
          <div class="drawer-header">
            <h3 class="drawer-title">${show.title}</h3>
            <button class="drawer-close" id="drawerClose"><i class="fas fa-times"></i></button>
          </div>
          ${html}
        `;

        // Bind events
        elements.playlistDrawer.querySelectorAll('.drawer-item').forEach(item => {
          item.addEventListener('click', () => {
            const newVideoId = item.dataset.videoId;
            if (newVideoId === videoId) {
              closePlaylist();
              return;
            }
            
            if (item.classList.contains('locked')) {
              toastMsg('üîí ‡§Ø‡§π ‡§è‡§™‡§ø‡§∏‡•ã‡§° GOLD subscribers ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡•à');
              return;
            }
            
            // Navigate to new video
            window.location.href = `${location.pathname}?v=${newVideoId}`;
          });
        });

        // Re-bind close button
        document.getElementById('drawerClose')?.addEventListener('click', closePlaylist);
      }

      function openPlaylist() {
        renderPlaylist();
        elements.playlistDrawer.classList.add('open');
        elements.backdrop.classList.add('show');
      }

      function closePlaylist() {
        elements.playlistDrawer.classList.remove('open');
        elements.backdrop.classList.remove('show');
      }

      // ========== EVENT LISTENERS ==========
      function setupEventListeners() {
        // Security
        document.addEventListener('contextmenu', e => e.preventDefault());
        document.addEventListener('keydown', e => {
          if (e.key === 'F12' || (e.ctrlKey && e.key === 'u')) e.preventDefault();
        });

        // Controls
        elements.playlistToggle.addEventListener('click', openPlaylist);
        elements.backBtn.addEventListener('click', () => history.back());
        elements.backdrop.addEventListener('click', closePlaylist);

        // Play/Pause on center button
        elements.centerPlay.addEventListener('click', () => {
          if (elements.video.paused) {
            elements.video.play().catch(() => {});
          } else {
            elements.video.pause();
          }
        });

        setupGestures();
        setupProgressBar();
        setupVideoEvents();
      }

      // ========== INIT ==========
      async function init() {
        setupEventListeners();
        await loadData();
      }

      // Start
      init();

      // Cleanup on unload
      window.addEventListener('beforeunload', () => {
        saveProgress();
        if (window.currentBlobUrl) {
          URL.revokeObjectURL(window.currentBlobUrl);
        }
      });

    })();
  </script>
</body>
</html>